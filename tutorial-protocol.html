<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>libdill</title>
  <link rel="stylesheet" type="text/css" href="http://libdill.org/main.css">
</head>
<body>

<h1>libdill: Structured Concurrency for C</h1>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="tutorial.html">Tutorials</a></li>
</ul>
<h1 id="tutorial-implementing-a-network-protocol">Tutorial: Implementing a network protocol</h1>
<h2 id="introduction">Introduction</h2>
<p>In this tutorial you will learn how to implement a simple network protocol using libdill.</p>
<p>The source code for individual steps of this tutorial can be found in <code>tutorial/protocol</code> subdirectory.</p>
<p>Please note that the test program as presented in this text is kept succint by ommitting all the asserts. The source code files for the tutorial, however, do the error checking properly.</p>
<h2 id="step-1-creating-a-handle">Step 1: Creating a handle</h2>
<p>Handles are libdill's equivalent of file descriptors. A socket implementing our protocol will be pointed to by a handle. Therefore, we have to learn how to create custom handle types.</p>
<p>Standard include file for libdill is <code>libdill.h</code>. In this case, however, we will include <code>libdillimpl.h</code> which defines all the functions <code>libdill.h</code> does but also adds some extra stuff that can be used to implement different plugins to libdill, such as new handle types or new socket types:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;libdillimpl.h&gt;</span></code></pre>
<p>To make it clear what API we are trying to implement, let's start with a simple test program. We'll call our protocol <code>quux</code> and at this point we will just open and close the handle:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(<span class="dt">void</span>) {
    <span class="dt">int</span> h = quux_open();
    hclose(h);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>To start with the implementation we need a structure to hold data for the handle. At the moment it will contain only handle's virtual function table:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> quux {
    <span class="kw">struct</span> hvfs hvfs;
};</code></pre>
<p>Let's add forward declarations for functions that will be filled into the virtual function table. We'll learn what each of them is good for shortly:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">void</span> *quux_hquery(<span class="kw">struct</span> hvfs *hvfs, <span class="dt">const</span> <span class="dt">void</span> *id);
<span class="dt">static</span> <span class="dt">void</span> quux_hclose(<span class="kw">struct</span> hvfs *hvfs);
<span class="dt">static</span> <span class="dt">int</span> quux_hdone(<span class="kw">struct</span> hvfs *hvfs, <span class="dt">int64_t</span> deadline);</code></pre>
<p>The <code>quux_open</code> function itself won't do much except for allocating the object, filling in the table of virtual functions and registering it with libdill runtime:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_open(<span class="dt">void</span>) {
    <span class="dt">int</span> err;
    <span class="kw">struct</span> quux *self = malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> quux));
    <span class="kw">if</span>(!self) {err = ENOMEM; <span class="kw">goto</span> error1;}
    self-&gt;hvfs.query = quux_hquery;
    self-&gt;hvfs.close = quux_hclose;
    self-&gt;hvfs.done = quux_hdone;
    <span class="dt">int</span> h = hmake(&amp;self-&gt;hvfs);
    <span class="kw">if</span>(h &lt; <span class="dv">0</span>) {<span class="dt">int</span> err = errno; <span class="kw">goto</span> error2;}
    <span class="kw">return</span> h;
error2:
    free(self);
error1:
    errno = err;
    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
<p>Function <code>hmake()</code> does the trick. You pass it a virtual function table and it returns a handle. When the standard function like <code>hclose()</code> is called on the handle libdill will forward the call to the corresponding virtual function, in this particular case to <code>quux_hclose()</code>. The interesting part is that the first argument to the virtual function is no longer the handle but rather pointer to the virtual function table. And given that virtual function table is a member of <code>struct quux</code> it's easy to convert it to the pointer to the quux object itself.</p>
<p><code>quux_hclose()</code> virtual function will deallocate the quux object:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">void</span> quux_hclose(<span class="kw">struct</span> hvfs *hvfs) {
    <span class="kw">struct</span> quux *self = (<span class="kw">struct</span> quux*)hvfs;
    free(self);
}</code></pre>
<p>At the moment we can just return <code>ENOTSUP</code> from the other two virtual functions.</p>
<p>Compile the file and run it to test whether it works as expected:</p>
<pre><code>$ gcc -o step1 step1.c -ldill</code></pre>
<h2 id="step-2-implementing-an-operation-on-the-handle">Step 2: Implementing an operation on the handle</h2>
<p>Consider a UDP socket. It is actually multiple things. It's a handle and as such it exposes functions like <code>hclose()</code>. It's a message socket and as such it exposes functions like <code>msend()</code> and <code>mrecv()</code>. It's also a UDP socket per se and as such it exposes functions like <code>udp_send()</code> or <code>udp_recv()</code>.</p>
<p>libdill provides an extremely generic mechanism to address this multi-faceted nature of handles. In fact, the mechanism is so generic that it's almost silly. There's a <code>hquery()</code> function which takes ID as an argument and returns a void pointer. No assumptions are made about the nature of the ID or nature of the returned pointer. Everything is completely opaque.</p>
<p>To see how that can be useful let's implement a new quux function.</p>
<p>First, we have to define an ID for <code>quux</code> object type. Now, this may be a bit confusing, but the ID is actually a void pointer. The advantage of using a pointer as an ID is that if it was an integer you would have to worry about ID collisions, especially if you defined IDs in different libraries that were then linked together. With pointers there's no such problem. You can take a pointer to a global variable and it is guaranteed to be unique as two pieces of data can't live at the same memory location.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> quux_type_placeholder = <span class="dv">0</span>;
<span class="dt">static</span> <span class="dt">const</span> <span class="dt">void</span> *quux_type = &amp;quux_type_placeholder;</code></pre>
<p>Second, let's implement <code>hquery()</code> virtual function, empty implementation of which has been created in previous step of this tutorial:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">void</span> *quux_hquery(<span class="kw">struct</span> hvfs *hvfs, <span class="dt">const</span> <span class="dt">void</span> *id) {
    <span class="kw">struct</span> quux *self = (<span class="kw">struct</span> quux*)hvfs;
    <span class="kw">if</span>(id == quux_type) <span class="kw">return</span> self;
    errno = ENOTSUP;
    <span class="kw">return</span> NULL;
}</code></pre>
<p>To understand what this is good for think of it from user's perspective: You call <code>hquery()</code> function and pass it a handle and the ID of quux handle type. The function will fail with <code>ENOTSUP</code> if the handle is not a quux handle. It will return pointer to <code>quux</code> structure if it is. You can use the returned pointer to perform useful work on the object.</p>
<p>But wait! Doesn't that break encapsulation? Anyone can call <code>hquery()</code> function, get the pointer to raw quux object and mess with it in unforeseen ways.</p>
<p>But no. Note that <code>quux_type</code> is defined as static. The ID is not available anywhere except in the file that implements quux handle. No external code will be able to get the raw object pointer. The encapsulation works as expected after all.</p>
<p>All that being said, we can finally implement our new user-facing function:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_frobnicate(<span class="dt">int</span> h) {
    <span class="kw">struct</span> quux *self = hquery(h, quux_type);
    <span class="kw">if</span>(!self) <span class="kw">return</span> -<span class="dv">1</span>;
    printf(<span class="st">&quot;Kilroy was here!</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Modify the test to call the new function, compile it and run it:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(<span class="dt">void</span>) {
    <span class="dt">int</span> h = quux_open(); 
    quux_frobnicate(h);
    hclose(h);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="step-3-attaching-and-detaching-a-socket">Step 3: Attaching and detaching a socket</h2>
<p>Let's turn the quux handle that we have implemented into quux network socket now.</p>
<p>libdill recognizes two kinds of network sockets: bytestream sockets and messages sockets. The main difference between the two is that the latter preserves the message boundaries while the former does not.</p>
<p>So, let's say quux will be a message-based protocol.</p>
<p>Also, we won't implement the entire network stack from scratch. The user will layer the quux socket on top of an existing bytestream protocol, such as TCP. The layering will be done via <code>quux_attach()</code> and <code>quux_detach()</code> functions.</p>
<p>In the test program we are going to layer quux protocol on top of ipc protocol (UNIX domain sockets):</p>
<pre class="sourceCode c"><code class="sourceCode c">coroutine <span class="dt">void</span> client(<span class="dt">int</span> s) {
    quux_attach(s);
    <span class="co">/* Do stuff here! */</span>
    s = quux_detach(q);
    hclose(s);
}

<span class="dt">int</span> main(<span class="dt">void</span>) {
    <span class="dt">int</span> ss[<span class="dv">2</span>];
    ipc_pair(ss);
    go(client(ss[<span class="dv">0</span>]));
    <span class="dt">int</span> q = quux_attach(ss[<span class="dv">1</span>]);
    <span class="co">/* Do stuff here! */</span>
    <span class="dt">int</span> s = quux_detach(q);
    hclose(s);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>To implement such socket it first needs to remember the handle of the underlying protocol so that it can use it when sending and receiving data:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> quux {
    ...
    <span class="dt">int</span> u;
};</code></pre>
<p>To accomodate libdill's naming conventions for protocols running on top of other protocols, we have to rename <code>quux_open()</code> to <code>quux_attach()</code>. Attach function will accept a handle of the underlying bytestream protocol and create quux protocol on top of it:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_attach(<span class="dt">int</span> u) {
    <span class="dt">int</span> err;
    <span class="kw">struct</span> quux *self = malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> quux));
    <span class="kw">if</span>(!self) {err = ENOMEM; <span class="kw">goto</span> error1;}
    self-&gt;hvfs.query = quux_hquery;
    self-&gt;hvfs.close = quux_hclose;
    self-&gt;hvfs.done = quux_hdone;
    self-&gt;u = u;
    <span class="dt">int</span> h = hmake(&amp;self-&gt;hvfs);
    <span class="kw">if</span>(h &lt; <span class="dv">0</span>) {<span class="dt">int</span> err = errno; <span class="kw">goto</span> error2;}
    <span class="kw">return</span> h;
error2:
    free(self);
error1:
    errno = err;
    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
<p>We can reuse <code>quux_frobnicate()</code> and rename it to <code>quux_detach()</code> which will terminate the quux protocol and return the handle of the underlying protocol:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_detach(<span class="dt">int</span> h) {
    <span class="kw">struct</span> quux *self = hquery(h, quux_type);
    <span class="kw">if</span>(!self) <span class="kw">return</span> -<span class="dv">1</span>;
    <span class="dt">int</span> u = self-&gt;u;
    free(self);
    <span class="kw">return</span> u;
}</code></pre>
<h2 id="step-4-sending-and-receiving-messages">Step 4: Sending and receiving messages</h2>
<p>Now that we've spent previous three steps with boring scaffolding work we can finally do some fun protocol stuff.</p>
<p>Modify the test program to send a simple text message to one end of the connection and receive it at the other end:</p>
<pre class="sourceCode c"><code class="sourceCode c">coroutine <span class="dt">void</span> client(<span class="dt">int</span> s) {
    ...
    msend(q, <span class="st">&quot;Hello, world!&quot;</span>, <span class="dv">13</span>, -<span class="dv">1</span>);
    ...
}

<span class="dt">int</span> main(<span class="dt">void</span>) {
    ...
    <span class="dt">char</span> buf[<span class="dv">256</span>];
    ssize_t sz = mrecv(q, buf, <span class="kw">sizeof</span>(buf), -<span class="dv">1</span>);
    printf(<span class="st">&quot;%.*s</span><span class="ch">\n</span><span class="st">&quot;</span>, (size_t)sz, buf);
    ...
}</code></pre>
<p>If you run the test program now it will fail becuase <code>msend()</code> and <code>mrecv()</code> are returning <code>ENOTSUP</code> error.</p>
<p>To fix the problem we will implement <code>msock</code> virtual function table:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> quux {
    <span class="kw">struct</span> hvfs hvfs;
    <span class="kw">struct</span> msock_vfs mvfs;
    <span class="dt">int</span> u;
};</code></pre>
<p>Forward declarations for <code>msock</code> functions:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">int</span> quux_msendl(<span class="kw">struct</span> msock_vfs *mvfs,
    <span class="kw">struct</span> iolist *first, <span class="kw">struct</span> iolist *last, <span class="dt">int64_t</span> deadline);
<span class="dt">static</span> ssize_t quux_mrecvl(<span class="kw">struct</span> msock_vfs *mvfs,
    <span class="kw">struct</span> iolist *first, <span class="kw">struct</span> iolist *last, <span class="dt">int64_t</span> deadline);</code></pre>
<p>Fill in the virtual function table in <code>quux_attach()</code>:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_attach(<span class="dt">int</span> u) {
    ...
    self-&gt;mvfs.msendl = quux_msendl;
    self-&gt;mvfs.mrecvl = quux_mrecvl;
    ...
}</code></pre>
<p>Return the <code>msock</code> virtual function table when <code>hquery()</code> is called with libdill-defined <code>msock</code> type ID:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">void</span> *quux_hquery(<span class="kw">struct</span> hvfs *hvfs, <span class="dt">const</span> <span class="dt">void</span> *type) {
    <span class="kw">struct</span> quux *self = (<span class="kw">struct</span> quux*)hvfs;
    <span class="kw">if</span>(type == msock_type) <span class="kw">return</span> &amp;self-&gt;mvfs;
    <span class="kw">if</span>(type == quux_type) <span class="kw">return</span> self;
    errno = ENOTSUP;
    <span class="kw">return</span> NULL;
}</code></pre>
<p>Finally, we are going to add implementations for send and receive functions.</p>
<p>Note that <code>quux_msendl()</code> and <code>quux_mrecvl()</code> get pointer to to msock virtual function table. We'll have to convert it to the pointer to quux object. To make that easier let's define following handy macro. It will convert pointer to an embedded structure to a pointer of the enclosing structure:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define cont(ptr, type, member) \</span>
    ((type*)(((<span class="dt">char</span>*) ptr) - offsetof(type, member)))</code></pre>
<p>Using the <code>cont</code> macro we can convert the <code>mvfs</code> into pointer to quux object. For example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">int</span> quux_msendl(<span class="kw">struct</span> msock_vfs *mvfs,
      <span class="kw">struct</span> iolist *first, <span class="kw">struct</span> iolist *last, <span class="dt">int64_t</span> deadline) {
    <span class="kw">struct</span> quux *self = cont(mvfs, <span class="kw">struct</span> quux, mvfs);
    ...
}</code></pre>
<p>Let's say that quux protocol will prefix individual messages with 8-bit size. Our test message is going to look like this on the wire:</p>
<p><img src="hello.png" /></p>
<p>Given that size field is a single byte messages can be at most 255 bytes long. That may be a problem in real world protocol but this is just a tutorial so we are perfectly comfortable with small messages.</p>
<p>Note that payload data is passed to the send function in form of two pointers to something called <code>iolist</code>.</p>
<p>Iolists are libdill's alternative to POSIX iovecs. Where iovecs are arrays of buffers (so called scatter/gather arrays) iolists are linked lists of buffers. Very much like iovec, iolist has <code>iol_base</code> pointer pointing to the data and <code>iol_len</code> field containing the size of the data. Unlike iovec though it has <code>iol_next</code> field which points to the next buffer in the list. <code>iol_next</code> of the last item in the list is set to <code>NULL</code>.</p>
<p>To send a quux message one has to compute the size of the message first. We can do so by iterating over the iolist and summing all the buffer sizes. If size is greater than 255, it's an error. And actually, we'll use number 255 for a special purposes later on (to do terminal handshake), so let's limit the message size to 254 bytes:</p>
<pre class="sourceCode c"><code class="sourceCode c">size_t sz = <span class="dv">0</span>;
<span class="kw">struct</span> iolist *it;
<span class="kw">for</span>(it = first; it; it = it-&gt;iol_next)
    sz += it-&gt;iol_len;
<span class="kw">if</span>(sz &gt; <span class="dv">254</span>) {errno = EMSGSIZE; <span class="kw">return</span> -<span class="dv">1</span>;}</code></pre>
<p>Now we can send the size and the payload to the underlying socket:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint8_t</span> c = (<span class="dt">uint8_t</span>)sz;
<span class="dt">int</span> rc = bsend(self-&gt;u, &amp;c, <span class="dv">1</span>, deadline);
<span class="kw">if</span>(rc &lt; <span class="dv">0</span>) <span class="kw">return</span> -<span class="dv">1</span>;
rc = bsendl(self-&gt;u, first, last, deadline);
<span class="kw">if</span>(rc &lt; <span class="dv">0</span>) <span class="kw">return</span> -<span class="dv">1</span>;</code></pre>
<p>To indicate success the function should return zero.</p>
<p>As for receive function we'll have to read the 8-bit size first:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint8_t</span> c;
<span class="dt">int</span> rc = brecv(self-&gt;u, &amp;c, <span class="dv">1</span>, deadline);
<span class="kw">if</span>(rc &lt; <span class="dv">0</span>) <span class="kw">return</span> -<span class="dv">1</span>;</code></pre>
<p>User may pass in <code>NULL</code> instead of the iolist which means we should read and silently drop the message:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span>(!first) {
    rc = brecv(self-&gt;u, NULL, c, deadline);
    <span class="kw">if</span>(rc &lt; <span class="dv">0</span>) <span class="kw">return</span> -<span class="dv">1</span>;
    <span class="kw">return</span> c;
}</code></pre>
<p>The size of the message may not match size of the buffer supplied by the user. If message is larger than the buffer we will simply return an error. However, if message is smaller than the buffer there's a problem. Bytestream receive function has no size argument. It just receives data until the buffer is full. Therefore, we will have to shrink the buffer to the appropriate size.</p>
<p>We can do so by modifying the iolist. Note that in iolist-based functions the list is supposed to be unchanged when the function returns. However, it can be temporarily modified while the function is in progress. In other words, iolists are not guaranteed to be thread- or coroutine-safe.</p>
<p>Once the iolist is modified we can read the message payload from the underlying socket:</p>
<pre class="sourceCode c"><code class="sourceCode c">size_t rmn = c;
<span class="kw">struct</span> iolist *it = first;
<span class="kw">while</span>(<span class="dv">1</span>) {
    <span class="kw">if</span>(it-&gt;iol_len &gt;= rmn) <span class="kw">break</span>;
    rmn -= it-&gt;iol_len;
    it = it-&gt;iol_next;
    <span class="kw">if</span>(!it) {errno = EMSGSIZE; <span class="kw">return</span> -<span class="dv">1</span>;}
}
<span class="kw">struct</span> iolist orig = *it;
it-&gt;iol_len = rmn;
it-&gt;iol_next = NULL;
rc = brecvl(self-&gt;u, first, last, deadline);
*it = orig;
<span class="kw">if</span>(rc &lt; <span class="dv">0</span>) <span class="kw">return</span> -<span class="dv">1</span>;
<span class="kw">return</span> c;</code></pre>
<p>Compile and test the program!</p>
<h2 id="step-5-error-handling">Step 5: Error handling</h2>
<p>Consider the following scenario: User wants to receive a message. The message is 200 bytes long. However, after reading 100 bytes, receive function times out. That puts you, as the protocol implementor, into an unconfortable position. There's no way to push the 100 bytes that were already received back to the underlying socket. libdill sockets provide no API for that, but even in principle, it would mean that the underlying socket would need an unlimited buffer. Just imagine receiving a 1TB message and timing out just before its fully read...</p>
<p>libdill solves this problem by not trying too hard to recover from errors, even from seemingly recoverable ones like ETIMEOUT.</p>
<p>When building on top of a bytestream protocol, which in unrecoverable by definition, you thus have to track failures and once error happens return an error for any subsequent attampts to receive a message. Same reasoning and same solution applies to outbound messages.</p>
<p>(Note that this does not apply when you are building on top of a message socket. Message sockets may be recoverable. Consider UDP. Thus, in that case you should just forward any send and received requests to the underlying socket and let it take care of error handling for you.)</p>
<p>Anyway, to implement error handling in quux protocol, let's add to booleans to the socket to track whether sending/receiving had failed already:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> quux {
    <span class="kw">struct</span> hvfs hvfs;
    <span class="kw">struct</span> msock_vfs mvfs;
    <span class="dt">int</span> u;
    <span class="dt">int</span> senderr;
    <span class="dt">int</span> recverr;
};</code></pre>
<p>Initialize them to false in <code>quux_attach()</code> function:</p>
<pre class="sourceCode c"><code class="sourceCode c">self-&gt;senderr = <span class="dv">0</span>;
self-&gt;recverr = <span class="dv">0</span>;</code></pre>
<p>Set <code>senderr</code> to true every time when sending fails and <code>recverr</code> to true every time when receiving fails. For example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span>(sz &gt; <span class="dv">253</span>) {self-&gt;senderr = <span class="dv">1</span>; errno = EMSGSIZE; <span class="kw">return</span> -<span class="dv">1</span>;}</code></pre>
<p>Finally, fail send and receive function if the error flag is set:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">int</span> quux_msendl(<span class="kw">struct</span> msock_vfs *mvfs,
      <span class="kw">struct</span> iolist *first, <span class="kw">struct</span> iolist *last, <span class="dt">int64_t</span> deadline) {
    <span class="kw">struct</span> quux *self = cont(mvfs, <span class="kw">struct</span> quux, mvfs);
    <span class="kw">if</span>(self-&gt;senderr) {errno = ECONNRESET; <span class="kw">return</span> -<span class="dv">1</span>;}
    ...
}</code></pre>
<h2 id="step-6-initial-handshake">Step 6: Initial handshake</h2>
<p>Let's say we want to support mutliple versions of quux protocol. When a quux connection is established peers will exchange their version numbers and if they don't match, they will fail.</p>
<p>In fact, we don't even need proper handshake for that. Each peer can simply send its version number and wait for version number from the other party. We'll do this work in <code>quux_attach()</code> function. And given that sending and receiving are blocking operations <code>quux_attach()</code> will become a blocking operation itself:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_attach(<span class="dt">int</span> u, <span class="dt">int64_t</span> deadline) {
    ...
    <span class="dt">const</span> <span class="dt">int8_t</span> local_version = <span class="dv">1</span>;
    <span class="dt">int</span> rc = bsend(u, &amp;local_version, <span class="dv">1</span>, deadline);
    <span class="kw">if</span>(rc &lt; <span class="dv">0</span>) {err = errno; <span class="kw">goto</span> error2;}
    <span class="dt">uint8_t</span> remote_version;
    rc = brecv(u, &amp;remote_version, <span class="dv">1</span>, deadline);
    <span class="kw">if</span>(rc &lt; <span class="dv">0</span>) {err = errno; <span class="kw">goto</span> error2;}
    <span class="kw">if</span>(remote_version != local_version) {err = EPROTO; <span class="kw">goto</span> error2;}
    ...
}</code></pre>
<p>Note that failure of initial handshake not only prevents initialization of quux socket, it also closes the underlying socket. This is necessary because otherwise the underlying sockets will be left in undefined state, with just half of quux handshake being done.</p>
<p>Of course, we'll have to modify the test program to pass deadlines to <code>quux_attach()</code> function invocations.</p>
<h2 id="step-7-terminal-handshake">Step 7: Terminal handshake</h2>
<p>Imagine that user wants to close the quux protocol and start a new protocol, say HTTP, on top of the same underlying connection. For that to work both peers would have to make sure that they've received all quux-related data before proceeding. If they did not the leftover quux data would confuse the subsequent HTTP protocol.</p>
<p>To achieve that peers will send a single termination byte (255) each to another to mark end of the stream of quux messages. After doing so they will read any receive and drop quux messages from the peer until they receive the 255 byte. At that point all the quux data are cleaned up, both peers have consistent view of the world and HTTP protocol can be safely initiated.</p>
<p>Let's add to flags to the quux socket object, one meaning &quot;termination byte was already sent&quot;, the other &quot;termination byte was already received&quot;:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> quux {
    ...
    <span class="dt">int</span> senddone;
    <span class="dt">int</span> recvdone;
};</code></pre>
<p>The flags have to be initialized in the <code>quux_attach()</code> function:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_attach(<span class="dt">int</span> u, <span class="dt">int64_t</span> deadline) {
    ...
    self-&gt;senddone = <span class="dv">0</span>;
    self-&gt;recvdone = <span class="dv">0</span>;
    ...
}</code></pre>
<p>If termination byte was already sent send function should return <code>EPIPE</code> error:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">int</span> quux_msendl(<span class="kw">struct</span> msock_vfs *mvfs,
      <span class="kw">struct</span> iolist *first, <span class="kw">struct</span> iolist *last, <span class="dt">int64_t</span> deadline) {
    ...
    <span class="kw">if</span>(self-&gt;senddone) {errno = EPIPE; <span class="kw">return</span> -<span class="dv">1</span>;}
    ...

}</code></pre>
<p>If termination byte was already received receive function should return <code>EPIPE</code> error. Also, we should handle the case when termination byte is originally received from the peer:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> ssize_t quux_mrecvl(<span class="kw">struct</span> msock_vfs *mvfs,
      <span class="kw">struct</span> iolist *first, <span class="kw">struct</span> iolist *last, <span class="dt">int64_t</span> deadline) {
    ...
    <span class="kw">if</span>(self-&gt;recvdone) {errno = EPIPE; <span class="kw">return</span> -<span class="dv">1</span>;}
    ...
    <span class="kw">if</span>(c == <span class="dv">255</span>) {self-&gt;recvdone = <span class="dv">1</span>; errno = EPIPE; <span class="kw">return</span> -<span class="dv">1</span>;}
    ...
}</code></pre>
<p>Virtual function <code>hdone()</code> that we've so far left unimplemented is supposed to start the terminal handshake. However, it is not supposed to wait till it is finished. The semantics of <code>hdone()</code> &quot;user is not going to send more data&quot;. You can think of it as an EOF marker of kind.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">int</span> quux_hdone(<span class="kw">struct</span> hvfs *hvfs, <span class="dt">int64_t</span> deadline) {
    <span class="kw">struct</span> quux *self = (<span class="kw">struct</span> quux*)hvfs;
    <span class="kw">if</span>(self-&gt;senddone) {errno = EPIPE; <span class="kw">return</span> -<span class="dv">1</span>;}
    <span class="kw">if</span>(self-&gt;senderr) {errno = ECONNRESET; <span class="kw">return</span> -<span class="dv">1</span>;}
    <span class="dt">uint8_t</span> c = <span class="dv">255</span>;
    <span class="dt">int</span> rc = bsend(self-&gt;u, &amp;c, <span class="dv">1</span>, deadline);
    <span class="kw">if</span>(rc &lt; <span class="dv">0</span>) {self-&gt;senderr = <span class="dv">1</span>; <span class="kw">return</span> -<span class="dv">1</span>;}
    self-&gt;senddone = <span class="dv">1</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>At this point we can modify <code>quux_detach()</code> function so that it properly cleans up any leftover protocol data.</p>
<p>First, it will send the termination byte if it was not already sent. Then it will receive and drop messages until it receives the termination byte:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> quux_detach(<span class="dt">int</span> h, <span class="dt">int64_t</span> deadline) {
    <span class="dt">int</span> err;
    <span class="kw">struct</span> quux *self = hquery(h, quux_type);
    <span class="kw">if</span>(!self) <span class="kw">return</span> -<span class="dv">1</span>;
    <span class="kw">if</span>(self-&gt;senderr || self-&gt;recverr) {err = ECONNRESET; <span class="kw">goto</span> error;}
    <span class="kw">if</span>(!self-&gt;senddone) {
        <span class="dt">int</span> rc = quux_hdone(&amp;self-&gt;hvfs, deadline);
        <span class="kw">if</span>(rc &lt; <span class="dv">0</span>) {err = errno; <span class="kw">goto</span> error;}
    }
    <span class="kw">while</span>(<span class="dv">1</span>) {
        ssize_t sz = quux_mrecvl(&amp;self-&gt;mvfs, NULL, NULL, deadline);
        <span class="kw">if</span>(sz &lt; <span class="dv">0</span> &amp;&amp; errno == EPIPE) <span class="kw">break</span>;
        <span class="kw">if</span>(sz &lt; <span class="dv">0</span>) {err = errno; <span class="kw">goto</span> error;}
    }
    <span class="dt">int</span> u = self-&gt;u;
    free(self);
    <span class="kw">return</span> u;
error:
    quux_hclose(&amp;self-&gt;hvfs);
    errno = err;
    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
</body>
